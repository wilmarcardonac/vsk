<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>LevelS SHT library: Introduction to libsharp</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="introduction">Introduction to libsharp </a></h1>"SHARP" is an acronym for <em>Spherical HARmonic Package</em>. All user-visible data types and functions in this library start with the prefix "sharp_" to avoid pollution of the global C namespace.<p>
<em>libsharp</em>'s main functionality is the conversion between <em>maps</em> on the sphere and <em>spherical harmonic coefficients</em> (or <em>a_lm</em>). A map is defined as a set of <em>rings</em>, which in turn consist of individual pixels that <ul>
<li>
all have the same colatitude and </li>
<li>
are uniformly spaced in azimuthal direction. </li>
</ul>
Consequently, a ring is completely defined by <ul>
<li>
its colatitute (in radians) </li>
<li>
the number of pixels it contains </li>
<li>
the azimuth (in radians) of the first pixel in the ring </li>
<li>
the weight that must be multiplied to every pixel during a map analysis (typically the solid angle of a pixel in the ring)  </li>
<li>
the offset of the first ring pixel in the <em>map array</em> </li>
<li>
the stride between consecutive pixels in the ring. </li>
</ul>
The map array is a one-dimensional array of type <em>float</em> or <em>double</em>, which contains the values of all map pixels. It is assumed that the pixels of every ring are stored inside this array in order of increasing azimuth and with the specified stride. Note however that the rings themselves can be stored in any order inside the array.<p>
The a_lm array is a one-dimensional array of type <em>complex float</em> or <em>complex double</em>, which contains all spherical harmonic coefficients for a full or partial set of m quantum numbers with 0&lt;=m&lt;=mmax and m&lt;=l&lt;=lmax. There is only one constraint on the internal structure of the array, which is:<p>
<code>Index[a_l+1,m] = Index[a_l,m] + stride</code><p>
That means that coefficients with identical <em>m</em> but different <em>l</em> can be interpreted as a one-dimensional array in <em>l</em> with a unique stride.<p>
Several functions are provided for efficient index computation in this array; they are documented <a class="el" href="group__almgroup.html">here</a>.<p>
Information about a pixelisation of the sphere is stored in objects of type sharp_geom_info. It is possible to create such an object for any supported pixelisation by using the function sharp_make_geometry_info(); however, several easier-to-use functions are <a class="el" href="group__geominfogroup.html">supplied</a> for generating often-used pixelisations like ECP grids, Gaussian grids, and Healpix grids.<p>
Currently, libsharp supports the following kinds of transforms: <ul>
<li>
scalar a_lm to map </li>
<li>
scalar map to a_lm<p>
</li>
<li>
spin a_lm to map </li>
<li>
spin map to a_lm </li>
<li>
scalar a_lm to maps of first derivatives </li>
</ul>
<p>
libsharp supports shared-memory parallelisation via OpenMP; this feature will be automatically enabled if the compiler supports it.<p>
Libsharp will also make use of SSE2 and AVX instructions when compiled for a platform known to support them.<p>
Support for MPI-parallel transforms is also available; in this mode, every MPI task must provide a unique subset of the map and a_lm coefficients.<p>
The spherical harmonic transforms can be executed on double-precision and single-precision maps and a_lm, but for accuracy reasons the computations will always be performed in double precision. As a consequence, single-precision transforms will most likely not be faster than their double-precision counterparts, but they will require significantly less memory. </div>
<hr><address style="align: right;"><small>
Generated on Thu Oct 8 14:48:51 2015 for LevelS SHT library
</a> </small></address>
</body>
</html>
